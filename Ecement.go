package main

import (
	"flag"
	"fmt"
	"log"
	"runtime"
	"time"
    glfw "github.com/go-gl/glfw3"
    gl "github.com/go-gl/gl"
)

type Pixel struct {
	R, G, B, A float32
}

type intensityController interface {
	Begin(w *glfw.Window, num int) error
	Update(intensity []float32) error
}

var controller intensityController
var currIntensity []float32


// OpenGL and glfw need to be called from the main thread
func init() {
    runtime.LockOSThread()
	loadedShaders = make(map[string]gl.Shader)
}

func checkGLError() {
	glErr := gl.GetError()
	if glErr != 0 {
		log.Printf("GL Error Code: %d\n", int(glErr))
		panic("stack trace")
	}
}

func errorCallback(err glfw.ErrorCode, desc string) {
    log.Fatalf("%v: %v\n", err, desc)
}

func main() {
	flag.Parse()
	
	imagePaths := flag.Args()
	
	currIntensity = make([]float32, len(imagePaths))
	
	// if len(imagePaths) < 2 || len(imagePaths) > 10 {
	// 	log.Fatalf("Ecement requires n files, where 2 <= n <= 10\n")
	// }	
	
	width, height, err := getImageRes(imagePaths[0])
	if err != nil {
		log.Fatalf("Failed to read image: %v\n", err)
	}
	
	controller = &keyScroll{}
	// controller = &keyboard{}
	// controller = &sincos{}
	
	glfw.SetErrorCallback(errorCallback)
    if !glfw.Init() {
        return
    }
    defer glfw.Terminate()

	// Get the right version of OpenGL
	glfw.WindowHint(glfw.OpenglForwardCompatible, glfw.True)
	glfw.WindowHint(glfw.OpenglProfile, glfw.OpenglCoreProfile)
	glfw.WindowHint(glfw.ContextVersionMajor, 3)
	glfw.WindowHint(glfw.ContextVersionMinor, 2)
	
	//we don't handle this properly yet
	glfw.WindowHint(glfw.Resizable, glfw.False)

	_, monitorHeight, err := monitorResolution()
	if err != nil {
		log.Fatalf("Failed to discover monitor resolution: %v", err)
	}
	
	//create a window that is 80% of the monitors height,
	//with a width based on the aspect ratio of the input images
	windowHeight := int(0.8 * float64(monitorHeight))
	windowWidth := int(float64(width)/float64(height) * float64(windowHeight))

	window, err := openWindow("Ecement", windowWidth, windowHeight)
	if err != nil {
		log.Fatalf("Failed to open window: %v", err)
	}

	result := gl.Init()
	if result != 0 {
		log.Fatalf("Failed to initialize GLEW: %d", result)
	}
	//clear a spurious error sometimes generated by GLEW's initialization 
	gl.GetError()

	err = controller.Begin(window, len(imagePaths))
	if err != nil {
		log.Fatalf("Failed to initialze controller: %v", err)
	}
	
	//just drawing a rectangle
	VAO := gl.GenVertexArray()
	VAO.Bind()
	vertices := []float32{
		0.0, 1.0,	  // Top-left
		1.0, 1.0,     // Top-right
		1.0, 0.0,     // Bottom-right
		0.0, 0.0,     // Bottom-left
	}
	vertexBuf := gl.GenBuffer()
	vertexBuf.Bind(gl.ARRAY_BUFFER)
	gl.BufferData(gl.ARRAY_BUFFER, 4*len(vertices), vertices, gl.STATIC_DRAW)
	
	elements := []uint32{
		0, 1, 2,
		2, 3, 0,
	}
	elementBuf := gl.GenBuffer()
	elementBuf.Bind(gl.ELEMENT_ARRAY_BUFFER)
	gl.BufferData(gl.ELEMENT_ARRAY_BUFFER, 4*len(elements), elements, gl.STATIC_DRAW)
	
	
	//create a program to preprocess the images (apply F inverse then subtract base image)
	preprocess, err := loadProgram("vertex.glsl", "preprocess.glsl")
	if err != nil {
		log.Fatalf("Failed to load preprocessing program: %v", err)
	}
	
	//create a program to cement the images together (sum their pixel scaled by intensity factors)
	step, err := loadProgram("vertex.glsl", "cement.glsl")
	if err != nil {
		log.Fatalf("Failed to load cement program: %v", err)
	}
	
	//create a program to tone map the result by applying F to the cemented image
	final, err := loadProgram("vertex.glsl", "tonemap.glsl")
	if err != nil {
		log.Fatalf("Failed to load tonemap program: %v", err)
	}
	
	//set up the shader programs
	preprocess.Use()
	checkGLError()	
		
	posLocation := preprocess.GetAttribLocation("position")
	checkGLError()	
	posLocation.AttribPointer(2, gl.FLOAT, false, 0, nil)
	checkGLError()	
	posLocation.EnableArray()
	checkGLError()	
	
	oldlocation := preprocess.GetUniformLocation("img")
	oldlocation.Uniform1i(0)
	
	newlocation := preprocess.GetUniformLocation("base")
	newlocation.Uniform1i(1)
	checkGLError()	
		
	step.Use()
	posLocation = step.GetAttribLocation("position")
	posLocation.AttribPointer(2, gl.FLOAT, false, 0, nil)
	posLocation.EnableArray()
	checkGLError()	
	
	totalLocation := step.GetUniformLocation("total")
	totalLocation.Uniform1i(0)
	checkGLError()	
	
	imglocation := step.GetUniformLocation("img")
	imglocation.Uniform1i(1)
	checkGLError()	
	
	intensitylocation := step.GetUniformLocation("intensity")
	checkGLError()
	
	final.Use()
	posLocation = final.GetAttribLocation("position")
	posLocation.AttribPointer(2, gl.FLOAT, false, 0, nil)
	posLocation.EnableArray()
	checkGLError()	
	
	imglocation = final.GetUniformLocation("img")
	imglocation.Uniform1i(0)
	checkGLError()	
	
	//create framebuffers to render final outputs	
	fullSizeFBs := createFramebufferPair(width, height)
	
	//create framebuffers to render in real time for the current window
	windowFBs := createFramebufferPair(windowWidth, windowHeight)
	
	//load the textures
	preprocess.Use()
	gl.Viewport(0,0, width, height)
	
	vectors, err := loadImages(imagePaths, width, height)
	if err != nil {
		log.Fatalf("Failed to load images into texture: %v", err)
	}	
	
	//check that the images were loaded correctly
	
	checkGLError()
	
	screenFB := gl.Framebuffer(0)
				
	lastUpdated := time.Now()
	frames := 0
	shouldSave := false
	rawOutput := make([]Pixel, width*height)
	done := make(chan int, 100)
	saveOperations := 0
    for !window.ShouldClose() {
		frames++
					
		err = controller.Update(currIntensity)
		if err != nil {
			log.Printf("Failed to update controller state: %v", err)
			return
		}
		for i := range vectors {
			vectors[i].R = currIntensity[i]
			vectors[i].G = currIntensity[i]
			vectors[i].B = currIntensity[i]
		}
		
		
		//render to the screen
		step.Use()
		gl.Viewport(0,0, windowWidth, windowHeight)
		result := render(vectors, windowFBs, intensitylocation)
		
		gl.ActiveTexture(gl.TEXTURE0)
		result.Bind(gl.TEXTURE_2D)
		
		screenFB.Bind()
		final.Use()
		gl.DrawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, nil)
		
		checkGLError()		
	
		//save the output if the user wanted to
		if shouldSave {
			step.Use()
			gl.Viewport(0,0, width, height)
			result := render(vectors, fullSizeFBs, intensitylocation)
			
			gl.ActiveTexture(gl.TEXTURE0)
			result.Bind(gl.TEXTURE_2D)
		
			final.Use()
			gl.DrawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, nil)
			
			gl.ReadPixels(0, 0, width, height, gl.RGBA, gl.FLOAT, rawOutput)
		
			go func() {
				path := "output.jpg"
				err := saveToJPEG(path, width, height, rawOutput)
				if err != nil {
					log.Printf("Failed to save jpeg: %v", err)
				}
				done <- 1
			}()
			saveOperations++
			shouldSave = false	
		}
				
		glfw.PollEvents()
		now := time.Now()
		diff := now.Sub(lastUpdated)
		if diff > time.Second*2 {
			fmt.Printf("%.1f FPS\n", float64(frames)/diff.Seconds())
			lastUpdated = now
			frames = 0
		}
		
		window.SwapBuffers()
    }
	
	//wait for any remaining saves to complete
	for i := 0; i < saveOperations; i++ {
		<-done
	}	
}